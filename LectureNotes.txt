The goal is to not learn a specific language through this class, but instead that you've learned how to program.
-> unfortunately with a more traditional language, there's more distraction.

Human language is more complex and involves more syntax than computer language.
  However
Computer language requires you to be more precise.  Code ultimately needs to be correct (which goes without saying).

It's hard to become comfortable with the DESIGN of your code.

Integrated Develop Environments (IDEs): aka text editors.
-> these are tools that programmers use to write code (VS Code).

GUI: Graphical User Interface (basically the left side bar of VS code)

CLI: Command Line Interface (terminal) this is what we will mostly be dealing with.
  $ make *filename* = compiling.  You have to do this before the output will be correct.  Compiling is the process of taking in source code and putting out machine code (binary).
  $ ./file (this pulls up any file in your current folder)
  $ rm = remove file (this removes the file named 'file')
  $ ls = list (this lists all the files in your current folder, if you never want to use GUI)

SCRATCH: (hello, world) from scratch is 
C: printf("hello, world"); in C
  -> C must have double quotes, not single

SCRATCH: ask (What's your name) and wait; has an 'answer' bubble that writes in whatever the user inputs to the prompt
C: string answer = get_string("What's your name? ");
           👆🏼 this is the assignment operator, which means to store a value in a variable.  You read these right to left.  The value on the right is copied in to the value on the left.
  -> labeling it 'string' is telling the computer this is words
  -> 'int' would tell the computer this is numbers

\n is a way of creating a new line so the C program compiler doesn't print $... on the end of your program.
  -> / is an escape sequence
  -> n is for a new line

%s is a format code which serves as a placeholder.

arguments and parameters are synonymous: they are inputs to a function.

SCRATCH: when (green flag) clicked
C: 
  #include <stdio.h>  👈🏼 this is the library you've loaded, aka a Header File.  It's a menu of all the available funtions.
  #include <cs50.h>

  int main(void)
  {
    printf("Hello, world\n");
  }

cd : change directory
  cd .. : change to parent folder
  cd ../.. : change to grandparent folder
cp : copy
code filename.c : create a new file
ls : list the items in the directory
mkdir : make directory, aka create a new file
mv : move, or rename
rm : remove 
rmdir : remove directory, aka remove a file
./ : access the folder that's right here in this directory

ctrl-L is the same as 'clear' in terminal.

bool : true/false
char : single character
double : more numbers after the decimal point, something that is more precision
float : real number (something with a decimal point in it)
int : integer (numbers)
long : bigger integer
string : words

CS50 library:  these are asking the user for an input in the terminal.
get_char
get_double
get_float
get_int
get_long
get_string

Format Codes: (placeholders)
%c : char
%d : data
%f : float or double
%i : integer
%li : long integer
%s : string

Operators:
+ : add
- : subtract
* : multiply
/ : divide 
% : remainder operator 

Variables & Syntactic Sugar (ss):
  -> Syntactic Sugar : makes it easier to write fewer characters, but express your thoughts the same.

  int counter = 0; (scratch: set counter to 0)
  counter = counter + 1; (scratch: change counter by 1)
   -> ss: counter += 1;
    -> further ss: counter++; (can only do this with 1)

First argument in printf HAS TO BE A STRING.

With string, int, flow, char, use a finite number of bits.  With 32 bits you can count pretty high.
  -> 8 bits you can count as high as 256
  -> 32 bits gives you roughly 4 billion, which is the standard for mac and pc.
  -> using Long Integers (long, get_long, %li) gets you 64 bits which is still finite but much larger.

Typically if something is wrapped with parenthesis, it's a function.  There are exceptions:
  -> The word "if" is not a function, it's a programming construct or feature of the C languages that uses parenthesis for a boolean expression (x > y)

const tells the compiler that you can't change a variable.  It's common to capitalize const variables.
  -> Ex: cost int MINE = 2;

If you find yourself copying and pasting code, there's a good chance you're probably doing something wrong.

When asking the OR "||", you have to ask the same question on either side of it.

Single quotes '' are used for single characters in char.  
Double quotes "" are used for strings in str, even if there's only one character in the string but more applicable for entire words or multiple words.

WHILE loops are the same as the "forever (say meow)" in Scratch.  Variables in while loops are declared outside of the loop, which assumes it's going to continue to exist elsewhere in the program.
FOR loops are basically the same as while loops, but the conditions are all in the parenthesis to the right of "for".  Most people would probably use for loops once comfortable with them.
DO WHILE loops are similar to while loops, but it checks the condition last instead of first.
  -> these are good when you want to do something no matter what first, and then check some condition or boolean expression.
  -> they do nothing at first, then run once the set codition has been met
  -> if the "while" condition is satisfied, then the "do" will continue to run.  Once the "while" isn't satisfied, then the program moves on to the next lines of code.

i is like your counter.  You don't want to use counter, just use i, but it represents the integer of whatever variable you're attempting to loop on.

When you create a function, like meow.c, it has to be above the call of the function.  C reads top to bottom.  One workaround is to put the "void meow(void);" above everything else.  This is just for C, other programs will allow you to put your functions in any order.

If you're only declaring a variable to return a value, you don't need the variable and you can simply put "return".

Floating-point imprecision: refers to the inability for computers fundamentally to represent all possible real numbers in languages like C.
  -> if you change from a float to an integer, you'll get zeros because int always wants to give back an integer.  This is known as truncation.

Type Conversion: 

The next time the world might end is 19 January 2038, due to the amount of seconds since the "epoch" or January 1st, 1970, when computers came on to the scene.  
  -> most computers were counting seconds with 32 bits, which gets us roughly 2 billion seconds.  2 billion seconds is going to happen in 2038.
  -> the solution for this is more bits.  We're increasing to 64 bits, so it will be someone else's problem far in to the future.

SHORTS: 

Things that are unique to C.
  -> You typically don't have to declare a variable type (integer, character, word(strings)).  In C you need to specify the data type of every variable we create.
  
  -> Data Types and Variables :
    -> int
      -> the int data type is used for variables that will store integers.
      -> integers always take up 4 bytes of memory (32 bits).  This means the range of values they can store is necesarily limited to 32 bits worth of information.  This essentially means the range of integers we can store is from -2^31 - 2^31-1 (minus one because we have to leave room for zero).
        -> this is about negative 2 billion to positive 2 billion.
      -> unsigned int : 
        -> unsigned is a qualifier.  It modifies the data type slightly.  It can be applied to certain data types (including int), which effectively doubles the positive range of variables of that type, at the cost of disallowing any negative values.  (Approx 0 to 4 billion).
        -> you'll occasionally have use for unsigned variables in CS50.
    
    -> char
      -> The char data type is used for variables that will store single characters.
      -> Characters always take up 1 byte of memore (8 bits).  This means the range of values is limited to 8 bits worth of information.  This means they can only fit values in the range of -2^7 (-128) and 2^7-1 (127)
      -> Thanks to ASCII, we've developed a mapping of characters like A, B, C, etc to numeric values in the positive sides of this range.
        -> "A" maps to the number 65.  "a" is 97.  The character 0 (not the number 0), is 48.

    -> float 
      -> the float data type is used for variables that will store floating-point values, also known as real numbers.
      -> floating point values always take up 4 bytes of memore (32 bits).
      -> it's a little complicated to describe the range of float, but suffice it to say with 32 bits of precision, some of which might be used for an integver part, we are limited in how precise we can be.
      -> what that means, is that if you have a repeating decimal place and a large integer place, you might not be able to be as precise.  That's the limitation of the float.
    
    -> double
      -> like floats, the double data type is used for variables that will store floating-point values, also known as real numbers.
      -> the difference is that doubles are double precision.  They always take up 8 bytes of memory (64 bits).
      -> with an additional 32 bits of precision relative to a float, doubles allow us to specify much more precise real numbers.
      -> maybe we can hav pi to 30 places rather than pi to 7 places (like if we use a float).

    -> void 
      -> this is a type, but NOT a data type.
      -> functions can have a void return type, which just means they don't return a value.
      -> the parameter list of a function can also be void.  It simply means the function takes no parameters.
      -> for now, think of void more as a placeholder for "nothing".  It's more complex than taht, but this should suffice for the better part of the course.
      -> when typing int main(void), it's basically saying that main doesn't take any parameters.  There's no argument that gets passed in to main.  There is a way to pass arguments in to main, but so far what we've seen is main not taking any arguments.

    -> bool <cs50.h>
      -> used for variables that will store a Boolean value.  More precisely, they are capable only of storing one of two values: True and False.
      -> be sure to #include <cs50.h> atop you programs if you wish to usethe bool type.
    
    -> string <cs50.h>
      -> the string data type is used for variables that will store a series of characters, which programmers typically call a string.  These can be short, like a word or phrase, or long like a book.
      -> strings include things such as words, sentences, paragraphs, and the like.
      -> besure to #include <cs50.h> atop your programs if you wish to use this string type.

    -> structs
      -> allow you to group things like a variable and a string in to one unit.
    
    -> typedefs 
      -> "defined types", which allow you to create your own data types.

  -> Creating a variable:
   -> 1st give it a type
    -> 2nd give it a name (and a semi-colon at the end)
    -> Examples:
      int number;  (you've created a variable named "number", and it's capable of holding integer-type values)
      char letter;  (you've created a variable named "letter", and it's capagle of holding single character-type values)
  -> If you wish to create multiple variables of the same type, you specify the type name once, and then list as many variables of that type as you want.
    -> Examples: 
      -> int height, width;
        -> this is the same as putting int height; AND int width; on separate lines.  Same with below.
      -> float sqrt2, sqrt3, pi;
    -> in general, it's good practice to only declare variables when you need them.  This has to do with scope.  It used to be standard to create all your variables at the top, but now it's better practice to create them when you're using them.  Likely because this makes it so someone reading your code can quickly see what it's in reference to.

  -> Using a variable:
    -> Declaring & Assigning: after a variable has been declared, it's no longer necessary to specify that variable's type.  (In fact, doing so has some unintended consequences!)
      int number;  // declaration
      number = 17; // assignment
      char letter;  // declaration
      letter = 'H'; // assignment
    -> Initializing: if you are simlutaneously declaring and setting the value of a variable (sometimes called initializing), you can consolidate htis to one step.
      int number = 17;  // initialization
      char letter = 'H'; // initialization
    
  Operators in C 
  -> Arithmetic Operators: in order to manipulate and work with variables and values in C, we have a number of operators at our disposal
    -> +, -, *, /
      int x = y + 1;
      x = x * 5;

    -> Modulus operator (%), which gives us the remainder when the number on the left of the operator is divided by the number on the right. This is basically the long-division operator, where a remainder is or isn't generated.  if nothing is returned, the remainder equals zero, if not, the remainder is returned.
      int m = 13 % 4  // m is now 1
      
    -> C also provides a shorthand way to apply an arithmetic operator to a single variable.
      x = x * 5;
        👆🏼same👇🏼  (this trick works with all five basica arithmetic operators.)
      x *= 5;
      -> C provides a further shorthand for incrementing or decrementing a variable by 1.
        x++;
        x--;

  -> Boolean Expressions: 
    -> used in C for comparing values.  They evaluate to one of two possible values: True or False.  We can use the result of evaluating a Boolean expression in other programming constructs such as deciding which brand in a conditional to take, or determining whether a loop should continue to run.
    -> sometimes when working with Boolean expressions, we will use variables of type bool, but we don't have to.
    -> in C, EVERY non-zero value is equivalent to TRUE, and zero is FALSE.
    -> two main types of Boolean expressions: logical operators and relational operators.
      -> Logical Operators:
        -> Logical AND (&&) is true if and only if BOTH operands are true, otherwise false.
          true && true = true
          true && false = false
          false && true = false
          false && false = false 
        -> Logical OR (||) is true if and only if AT LEAST ONE operand is true, otherwise false.
          true && true = true
          true && false = true
          false && true = true
          false && false = false
        -> Logical NOT (!) inverts the value of its operand.  Sometimes pronounced as "bang", "exclamation", or "not".
          true = false
          false = true
      -> Relational Operators: these behave as you would expect them to, and appear syntactically similar to how you may recall them from elementary arithmetic.
        -> > < >= <=
          less than (x < y)
          greater than (x > y)
          less than or equal to (x <= y)
          greater than or equal to (x >= y)
        -> Equality and Inequality : be careful!  it's a common mistake to use the assignment operator (=) when you intend to use the equality operator (==).
          Equality ( x == y)
          Inequality (x != y)

  Conditionals
    -> Conditional expressions allow your program to make decisions and take different forks in the road, depending on the values of variables or user input.
    -> C provides a few different ways to implement conditional expressions (also known as branches) in your programs, some of which likely look familiar from Scratch.
    -> Examples:
      if (boolean-expression)
      {

      }
        -> if the boolean-expression evaluates to true, all lines of code between the curly braces will execute in order from top to bottom.
        -> if the boolean-expression evaluates to false, thoes lines of code will not execute.
      
      if (boolean-expression)
      {

      }
      else 
      {

      }
      -> if the boolean-expression evaluates to true, all lines of code between the first set of curly braces will execute in order from top to bottom.
      -> if the boolean-expression evaluates to false, all lines of code between the second set of curly braces will execute in order from top to bottom.
    
    -> You can also create an if, else if, else chain with multiple else ifs in the middle.  As you would expect, each branch in the below chain is mutually exclusive.
      if (boolean-expr1)
      {
        // first branch 
      }
      else if (boolean-expr2)
      {
        // second branch
      }
      else if (boolean-expr3)
      {
        // third branch
      }
      else 
      {
        // fourth branch
      }
    -> it is also possible to create a chain of non-mutually exclusive branches.
    -> in the below example, only the third and fourth branches are mutually exclusive.  The else binds to the nearest if only.
    -> say you satisfify the first and second condition and not the third, the program goes to the first, second, and fourth branch.
    -> the else will bind to the nearest if.
      if (boolean-expr1)
      {
        // first branch 
      }
      if (boolean-expr2)
      {
        // second branch
      }
      if (boolean-expr3)
      {
        // third branch
      }
      else 
      {
        // fourth branch
      }

  -> switch() statement: a conditional statement that permits enumeration of distinct cases, instead of relying on Boolean expressions.  It's important to break; between each case, or you will "fall through" each case (unless that is the desired behavior).
    -> Example:
      int x = GetInt();  // not sure if they meant to put "get_int" here, but both ways generate an error in vscode.
      switch(x)
      {
        case 1:
          printf("One!\n");
          break;
        case 2:
          printf("Two!\n");
          break;
        case 3:
          printf("Three!\n");
          break;
        default:
          printf("Sorry!\n");
          break;
      }

  -> Ternary Operator (?:)
    -> mostly a cute trick, the ternary operator (?:) is useful for writing trivially short conditional branches.  Be familiar with it, but know that you won't need to write it if you don't want to.
    -> these two snippets of code act identically
      int x;
      if (expr)
      {
        x = 5;
      }
      else 
      {
        x = 6;
      } 
      👆🏼 same 👇🏼  // just a slicker way of writing it
      int x = (boolean-expression) ? 5 : 6;  
  
Loops 
  -> loops allow your programs to execute lines of code repeatedly, saving you from needing to copy and paste or otherwise repeat lines of code.
  -> C provides a few different ways to implement loops in your programs, some of which likely look familiar from Scratch.
  -> if you every have a program that's running continuously and will crash the browser, hit CTRL-C and it will stop.
  -> loops are usually interchangeable, but it's good practice to use them specifically for the following:
    -> while loop : use when you want to loop to repeat an unknown number of times, or possible not loop at all.
      -> you might want to use this to run the control flow for a game. You might not know how long the user is going to be playing, but you want to keep doing the same thing (updating the various positions of sprites on the board, keeping things moving at all times).
    -> do-while loop : use when you want a loop to repeat an uknown number of times, but at least once.
      -> a common use case is prompting a user for input.  You might ask them for a positive integer, and if they give you a negative integer then the program will run again until they satisfy the false value of the boolean expression.
    -> for loop : use when you want a loop to repeat a discrete number of times, though you may not know the number at the moment the program is compiled.
      -> maybe you have a program where you prompt the user for a number, and they enter 100.  Then the program runs 100 times.  Or 1000, and then it runs 1000 times.  You don't know what the specific number of times is.


  -> While Loops
    -> infinite loop: the lines of code between the curly braces will execute repeatedly from top to bottom, until and unless we break out of it (as with a break; statement like we use in switch()), or otherwise kill our program.
      while (true)
      {

      }
    -> repeat until (from scratch): if the boolean expression evaluates to true, all lines of code between the curly braces will execute repeatedly, in order from top to bottom, until boolean-expression evaluates to false.
      while (boolean-expression)
      {

      }
  
  -> Do While Loops: this loop will execute all lines of code between the curly braces once, and then, if the boolean-expression evaluates to true, will go back and repeat that process until boolean-expression evaluates to false.
    do
    {

    }
    while (boolean-expression);

  -> For Loops: 
    -> syntactically unattractive, but for loops are used to repeat the body of a loop a specified number of times, in this example 10.  
    -> the process undertaken in a for loop is:
      -> the counter variable(s) (here, i) is set
      -> the Boolean expression is checked.
        -> if it evaluates to true, the body of the loop executes
        -> if it evaluates to false, the body of the loop does not execute.
      -> the counter variable is incremented, and then the boolean expression is checked again, etc.
    -> Example: 
      for (int i = 0; i < 10; i++)
      {

      }
      👆🏼AKA👇🏼
      for (start; expr; increment)
      {

      }
      1. the statement(s) in "start" are executed
      2. the "expr" is checked
        -> if it evaluates to true, the body of the loop executes
        -> if it evaluates to false, the body of the loop does not execute;
      3. the statement(s) in "increment" are executed, and then the "expr" is check again, etc.

Command Line
  GUI (graphical user interface) is utilizing your mouse to navigate your system.
  Using the command line works with UNIX-based systems, it's a way to do the same things you'd do with your mouse but instead with the command line.
  Commands:
    -> ls : "list command", gives you a readout of all the files and folders in your current directory.
    -> cd : "change directory", changes your current directory.  
      -> The shorthand name for the current directory is .
      -> The shorthand name for the parent directory is ..
      -> The shorthand name for the grandparent directory is ../..
      -> If you want to go back to the main directory, type cd and press enter (gets it back to where there's just a $)
    -> pwd : "present working directory", shows you the folders where you're current directory is set to.
    -> mkdir : "make directory", creates a new subdirectory located in the current directory. AKA, it's making a new folder.
    -> cp : "copy", allows you to create a dupliacte of a file
      -> cp <source> <destination> 
        -> you're duplicating the file you specify as <source>, and it will save the file in <destination>
      -> cp -r <source directory> <destination directory>
        -> if you wish to copy ENTIRE directories, use this.  The -r stands for "recursive", and tells cp to dive down into the directory and copy everything inside of it (including any subdirectories it might contain).
    -> rm : "remove", this will delete <file> after it asks you to confirm (y/n) you want to delete it.
      -> rm -f <file> 
        -> skips the file confirmation "forceably"
      -> rm -r <directory>
        -> deletes the entire directory
      -> you can also combine the -r and -f flags in to -reference  
        -> be careful, there's no undoing this!
    -> mv : "move", allows you to effectively rename a file, moving it from <source> to <destination>.
      -> this simplifies the process of duplicating a file that you've named wrongly and instead naming it rightly, then deleting the previous file.  It just renames it right away.
    -> chmod
    -> rmdir
    -> sudo 
    -> ln 
    -> man 
    -> clear 
    -> touch 
    -> diff 
    -> telnet


Lecture 2

  Clang = "C Language", which is the built in compiler utilized in the CS50 vs code program.
    -> clang -o hello hello.c
      -> creates a file called "a.out" for programs that don't require an additional library
    -> this becomes tedious, because you have to type "clang hello.c -o hello -lcs50" to utilize the cs50 library 
    -> "make" makes all this happen, this is just an explanation of what's happening
    -> when you input "make hello", the program is called make, and the command line argument is hello (argument is what you pass in to the program).

  Compiling is an oversimplification.  4 things are happening:
    -> Preprocessing
      -> these are the #include directives, called Preprocessor Directives, that we add at the top of C programs.
      -> they're handled specially apart from the rest of your code.  The libararies are accessing these programs for functions we input:
        -> get_string : string get_string(string prompt);
        -> printf : int printf(string format, ...);
    -> Compiling
      -> to take code that looks like human syntax and convert it to assembly language.  There are many different types of (or flavors of) assembly language.
      -> assembly language is about as low level as you can get to what a computer really understands before you start getting in to 0s and 1s.
    -> Assembling
    -> Linking

  Arrays
    -> 


Things that are new in 2023 (I missed some of them)

The most numbers you can represent with 32 bits: 4,294,967,295
  > typically half of these are negative, so the highest and lowest actual numbers most computers use is: 2,147,483,647 and -2,147,483,648 (remember that 0 counts here, that's why positive and negative are different).
  > once you run out, you've experienced Integer Overflow
The most numbers you can represent with 64 bits: 9,223,372,036,854,775,807 (9 Quintillion)

Truncation: lose everything after the decimal point due to floating-point division errors.

TypeCasting: convert one data type to another by explicitly telling the compiler that you want to do so.

Magic Numbers: directly writing constants in to our code.  Essentially hard coding?
  -> C provides a preprocessor directive (also called a macro) for creating symbolic constants.
    #define NAME REPLACEMENT
      -> At the time your program is compiled, #define goes through your code and replaces NAME with REPLACEMENT
      -> DON'T put a semi-colon at the end of this.
      -> If #include is similar to copy/paste, then #define is analogous to find/replace.
    #define PI 3.14159265
      -> At the time your program is compiled, #define goes through your code and replaces PI with 3.14159265.
    #define COURSE "CS50"
      -> #define goes through your code and replaces COURSE with "CS50".
    -> Example:
    #define DECKSIZE 52

    card deal_cards(deck name)
    {
      for (int i = 0; i < DECKSIZE; i++)
      {
        // deal the card
      }
    }

    CREDIT was intense!  That ended up being a tough one.  Lessons learned were:
      -> if you're trying to add a new function, you can't add it within int main(void) as that is a function itself.
      -> the modulus operator is sick.  You can use it to iterate through long numbers by dividing the long number by 10 each time and taking the % 10 (which defines the last byte).
      -> the more you stare at these, the easier they eventually become!
      -> I think I should try and make a loop out of the credit function somehow.  I don't know how yet though.  Let's give it a shot!




Lecture Week 2

Make is not actually a compiler.  It's a program that clearly makes your program, but it itself automates the process of using an actual compiler.
  -> clang is an actual compiler
  -> gcc is another compiler, been around for arguments

Clang will compile code and create a file called "a.out".  You can use ./ to run this compiled code.
  -> a.out is a historical name, refers to "assembler output".  It's the default file name that the compiler makes.

Clang supports command line arguments.  
  -> Command Line Arguments: unline an argument to a function, it's an additional word or key phrase that you type after your prompt in terminal that modifies the behavior of that command.
  -> Compile code and rename the compiled code at the same time:
          👇🏼output   👇🏼file you want to compile
    clang -o hello hello.c -lcs50  👈🏼adding the library you're using that's not included in C
    👆🏼compiler 👆🏼name of the compiled file
      -> "-o" means the output.  There are numerous options like it.
      -> "-lcs50" is the second step the compiler requires to load the specific library and utilize it.  Not necessary for built-in libraries.
      -> "make" is what we'll use to automate this entire process.

4 steps of Compiling: (this has been happening automatically thus far, converting source code to machine code.)
  1. Preprocessing
    -> lines of code that start with a # are preprocessor directives.  They are different than any other line, they should be analyzed initially before anything else is happening.
    -> there's a folder someowhere on each system that's called "/usr/include".  It's a folder that contains cs50.h, stdio.h, and others.
    -> similar to how we tease formulas prior to utilizing them in our program, the preprocessed lines are libraries of these type of formulas that are all teased and categorized in the <cs50.h> or <stdio.h> libraries.
  2. Compiling
    -> converting C to assembly code.  Assembly code is quite cryptic, and it's closer to what computers understand.
    -> computers understand more arithmetic operations, and moving things in and out etc.
  3. Assembling
    -> this is where things get converted to machine code.  Assembly code is converted to actual 0s and 1s.
    -> these aren't necessarily all the 0s and 1s to your program.  We need one final step.
  4. Linking 
    -> this combines the 0s and 1s that I wrote, with the 0s and 1s that the authors of <cs50.h> wrote, with the 0s and 1s that the <stdio.h> library, with the 0s and 1s of the original authors of C.
    -> links them all together to create a massive blob of 0s and 1s.  

Decompiling: reversing the process of compiling.  
  -> If anyone on the internet is able to decompile their code, it might be easier to hack.
  -> if your code is copyrighted, it's obnoxious that someone can see the original code that you wrote.
  -> it's not predictable that you'll get the exact source code as there are multiple different ways to write source code for the same thing.
  -> it's pretty challenging, time consuming, and costly to reverse engineeer the 0s and 1s.

Debugging 
  debug50: 
    -> debugging is for when your code compiles and runs, yet you're not getting the output you're looking for.  You can go step by step through it to see what in tarnation is going wrong.
    -> named after an actual moth that was causing problems for the Mark II.
    -> great way to debug is to use printf to try and find out where your mistake is.
    -> this can get messy and annoying.  Computer scientists have written software to make it easier to debug code, ie a debugger.
    -> typically there are configuration files you have to include when running a debugger, but CS50 has made it easier by doing those configurations for us.
    -> To Debug:
      -> hover over the far right of VS Code where the red dots come up
      -> Break Points: click on the red dot to make it brighter - this will tell your debugger to stop running the code there (kind of like a stop sign).
        -> it's typically a good idea to set break points on function lines, and the debugger will set them to places where actual code is happening.
      -> run "debug50 ./fileName"
      -> see the continue, step over, step into, step out, restart, and stop buttons.
        -> to continue one level through your code, press the step into button.

  Rubber Duck Debugging: 
    -> Talking through programs to see any illogical fallacies.


Data Types Usage:
 bool : 1 byte
 int : 4 bytes
 long : 8 bytes
 float : 4 bytes
 double : 8 bytes
 char : 1 byte
 string : ? bytes
 ...

 TypeCasting Example:
  -> (float) 3 , it's almost like timesing a 3 by a float, but it changes 3 to 3.0.  This is imperfect, but it can do the trick for floats to not many decimal points.


Array: 
  -> a way of storing your data, back to back to back in a computers memory, in a way that you can access each individual member easily.
  -> must start at 0.
  -> declaring an array:
    int variable[x];
  -> how to tell C that a function takes an array 
    float functionName(int array[]);
  
  Strings in Arrays 
    -> A string is technically an array of characters.
    -> when you use them, they automatically type "\0" as one additional character to define the end of the array.
      -> technically \0 is 8 bits of 0, also equal to "null".
    -> you don't need square brackets, a string is invariably an array that you can use square brackets to access.
      -> ie (this prints HI!):
        int main(void)
        {
          string s = "HI!";
          printf("%c%c%c\n", s[0], s[1], s[2]);
        }
    -> to access specific characters within multiple strings, do this:
      int main(void)
      {
        string words[2];

        words[0] = "HI!";
        words[1] = "BYE!";      👇🏼 string 0
                                   👇🏼 char 0
        printf("%c%c%c\n", words[0][0], words[0][1], words[0][2]);
        printf("%c%c%c%c\n", words[1][0], words[1][1], words[1][2], words[1][3]);
      }
  
  -> Arrays don't have the NULL character, but strings do.  Strings are special vs all the other data types thus far.
  
    -> here's how to manually get the length of a string:
      int main(void)
      {
        string name = get_string("What's your name? ");

        int n = 0;
        while (name[n] != '\0')
        {
          n++;
        }
        printf("%i\n", n);
      }
    
  -> #include <string.h> is a library of string-related functions.
    -> strlen() : gets the length of a string, skips all the above steps.
      int main(void)
      {
        string name = get_string("What's your name? ");
        int n = strlen(name);
        printf("%i\n", n);
      }
    
Changing uppercase characters in a string to lower case and vise versa:
  -> UPPER CASE & lower case are always 32 characters away from each other.
  -> 'A' = 65, 'B' = 66
  -> 'a' = 97, 'b' = 98
  -> Example:
    #include <cs50.h>
    #include <stdio.h>
    #include <string.h>

    int main(void)
    {
      string s = get_string("Before: ");
      printf("After:  ");
      for (int i = 0; i < strlen(s); i++)
      {
        if (s[i] >= 'a' && s[i] <= 'z')  // 👈🏼 this is legit because the letters represent number, 'a' is 97, 'b' is 98, 'A' is 65, 'B' is 66.
        {
          printf("%c", s[i] - 32);
        }
        else
        {
          printf("%c", s[i]);
        }
      }
      printf("\n");
    }
  
  BUT YOU CAN WRITE THIS 👆🏼 AN EASIER WAY! 👇🏼

  Add the library:
  #include <ctype.h>
  -> Example:
  int main(void)
  {
    string s = get_string("Before: ");
    printf("After:  ");               // this line is printing every time regardless, and then the next printf sits right beside it.
    for (int i = 0, n = strlen(s); i < n; i++)   // you can declare another variable within this loop, "n = strlen(s);".  This makes it so you don't have to call strlen() again and again throughout the loop, since it's always the same within the one function (until you get_string a new string obviously).
    {
        printf("%c", toupper(s[i]));  // toupper() knows to change lower case -32 and leave upper case alone.
    }
    printf("\n");                     // this gets you on a new line as soon as you iterate through the previous code, so it doesn't print one letter per line.
  }

The two official formats for defining a main function:
  int main(void) {}
  int main(int argc, string argv[]) {}


Fun Command Line Argument: 
-> cowsay
  cowsay moo
  cowsay -f duck quack
  cowsay -f dragon RAWR

echo$? is a command line argument that shows you what your program is returning.
  -> to get it to function properly, write "return 1" in the lines of code you write when you don't get what you want, and 0 when you get the correct one. 
  -> example:
    int main(int argc, string argv[])
    {
      if (argc <= 2)
      {
        printf("Missing additional command-line argument!  Type your whole name.  Now!\n");
        return 1;
      }
      else if (argc > 3)
      {
        printf("Too many arguments!  That's not your name.  Type your name!\n");
        return 1;
      }
      else
      {
        printf("Hello, %s %s\n", argv[1], argv[2]);
        // you can omit "return 0;" here, because it's automatic.
      }
    }

Cryptography: encryption and decryption (aka sending messages that you can't decode without the correct algorithm).
  plaintext -> 
                cipher -> cyphertext
        key ->
  -> an example is adding one to each letter, also called ceaser cipher, so each letter is one past the intended letter alphabetically.
  

Week 2 Shorts 

Functions 
  -> Function Declarations: these go on the top prior to defining the function to hint the compiler that they will be defined below and utilized throughout.

    return-type name(argument-list);

    -> return-type : what kind of variable the function will output
    -> name : what you want to call your function (try to make it as descriptive as possible)
    -> argument-list : the comma-separated set of inputs to your function, each of which has a type and a name.
    -> example: 

      int add_two_ints(int a, int b);
    
    -> create an example of a function dictation for a number with decimal places:

      float mult_two_reals(float x, float y);

    -> if you want to me more precise, that is, have more decimal places which are accurate, you can use double:

      double mult_two_reals(double x, double y);

  -> Function Definition: the second step to creating a function is to define it.  This allows for predictable behavior when the function is called with inputs.
    -> define mult_two_reals (the first one):

      float mult_two_reals(float x, float y)   <- (this is the input of the black box)
      {
        float product = x * y;                 <- (this is within the black box)
        return product;                        <- (this is the output of the black box)
      }

      You can simplify this 👆🏼 with this 👇🏼 

        float mult_two_reals(float x, float y) 
        {
          return x * y;
        }

    Define add_two_ints(int a, int b);

      int add_two_ints(int a, int b)
      {
        int addition = a + b;
        return addition;
      }

  -> Calling a function: 
    -> simply pass it appropriate arguments (int requires an int, etc)
    -> assign its return value to something of the correct type 

  -> Function Miscellany
    -> functions can sometimes take no inputs.  In that case, we declare the function as having a VOID ARGUMENT LIST.
      -> main is an example of this.
    -> functions sometimes do not have an output.  In that case, we declare the function as having a VOID RETURN TYPE.


Variables and Scope 
  -> Scope is a characteristic of a variable that defines from which functions that variable may be accessed.

  -Local vs Global Variables 

    -> Local variables can only be accessed within the functions in which they are created.
      -> Local variables are PASSED BY VALUE in function calls.  
      -> Passed by value means the callee (the function that is receiving the variable) receives a copy of the passed variable, not the variable itself.
      -> That means that the variable in the caller is unchanged unless overwritten.
      -> Here's an example of how to manipulate a local variable within two functions:
        int triple(int x);

        int main(void)
        {
          int foo = 4;
          foo = triple(foo);
        }

        int triple(int x)
        {
          return x *= 3;
        }

    -> Global variables can be accessed by any function in the program.  They are declared outside of all functions.
      -> Global variables can be manipulated by one function, and that manipulation carries over to the next function or functions.

  -> Things can get particularly insidious if the same variable name appears in multiple functions, which is perfectly okay as long as the variables exist in different scopes.


Debugging ("Step Through")
  -> set a break point by pressing one of the red buttons to the left
  -> run debug50 fileName 

Debugging ("Step In To")
  -> same process as above
  -> use the Step Into button (down arrow) to go within a function to see what's going on with the output.


Arrays
  -> a fundamental data structure, and they are extremely useful!
  -> we use arrays to hold values of the same type at contiguous memory locations.  AKA it's a way we can group a bunch of integers together in memory or a bunch of characters or floats in memory, really close together, and work with them without giving each one it's own unique name.
  -> one way to analogize the notion of array i to think of your local post office, which usually has a large bank of post office boxes.  Instead of post office boxes, arrays have elements, but they're the same idea.  Ways of grouping people's mail in one central location, and for arrays: grouping data in one central location.
  -> variables of the same data type can be stored within an array (int, float, char, etc).
  -> we can access each element of an array directly by the element's specific index number.
  -> in C, elements of an array are indexed starting from 0. (this is a major reason we count from 0!)
    -> if an array consists of n elements, the first element is located at index 0.  The last element is located at index (n-1).
  -> C is very lenient.  It will not prevent you from going "out of bounds" of your array; be careful!
    -> this is known as a "segmentation fault"

 -> Array Declarations:

    type name[size];

      -> the type is what kind of variable each element of the array will be
      -> the name is what you want to call your array
      -> the size is how many elements you would like your array to contain

  -> To declare and initialize an array simultaneously, there is a special syntax that may be used to fill up the array with its starting values.
    -> instantiation syntax:

      bool truthtable[] = { false, true, true };

      -> note, you don't have to input the array size when you use the instantiation syntax, the compiler is able to count them up for you.

    -> individual element syntax:

      bool truthtable[3];
      truthtable[0] = false;
      truthtable[1] = true;
      truthtable[2] = true;


  -> Arrays can consist of more than a single dimension.  You can have as many size specifiers as you wish.
    -> example:

      bool battleship[10][10];

      -> this gives you a 10x10 grid of cells.  In memory, thius is just a 100-element, one-dimensional array.
      -> multi-dimensional arrays are great abstractions to help visualize game boards or other complex representations.

  IMPORTANT 
  -> While we can treat individual elements of arrays as variables, we cannot treat entire arrays themselves as variables.
  -> We cannot, for instance, assign one array to another using the assignment operator (=).  That is not legal C.
  -> Instead, we must use a loop to copy over the elements one at a time.
  -> Arrays (unlike variables) do not follow the "passed by value" rule.  Instead, they are PASSED BY REFERENCE.  The callee receives the actual array, NOT its own local copy of it.


Command Line Arguments:
  -> most programs start like this:

    int main(void)
    {}
  
    -> we haven't had to modify main() due to the fact we've been collecting user input through in-program prompts.
    -> if we want the user to provide data to our program before the program starts running, we need a new form.

  -> To collect command-line arguments from the user, declare main as:

    int main(int argc, string argv[])
    {}          
                👆🏼 integer   👆🏼 array of strings  These two special argumens enable you to know what data the user provided at the command line and how much data they provided.
       
      argc (argument count) : this integer-type variable will store the number of command-line arguments the user typed when the program was executed.
        -> example
          ./greedy              1 argument
          ./greedy 1024 cs50    3 arguments

      argv (argument vector aka array) : this array of strings stores, one string per element, the actual text the user typed at the command line when the program was executed.  
        -> the first element of argv is always found at argv[0].  The last element of argv is always found at argv[argc-1].  This is because argc is the number of elements typed at the command line, and the array starts counting at 0.      
        -> example:
          
          ./greedy 1024 cs50

          argv indices        argv contents
            argv [0]            "./greedy"
            argv [1]              "1024"
            argv [2]              "cs50"
            argv [3]                ???        // this will likely give us a segmentation fault since it's overstepping our array.




Update for git.